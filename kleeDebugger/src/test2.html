<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klee Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* 全局样式 */
        html,
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', Arial, sans-serif;
            /* 使用更优雅的字体 */
            display: flex;
            flex-direction: column;
            /* 垂直排列 */
            justify-content: center;
            /* 页面水平居中 */
            align-items: center;
            /* 页面垂直居中 */
            min-height: 100vh;
            background-color: #f3f4f6;
            overflow: hidden;
            /* 确保不会出现滚动条 */
        }

        /* #svg-container {
            /* width: 85vw;
            height: 85vh; 
        overflow: hidden;
        /* 确保不会出现滚动条 
        width: 95%;
        height: 95%;
        /* 宽度修改为 100% 
        /* max-width: 1200px; 
        /* 可选：设置最大宽度 
        padding: 20px;
        /* 内边距 
        }

        */

        /* 主容器样式，分成三个大容器 */
        .main-container {
            display: flex;
            /* 水平布局 */
            flex-direction: column;
            /* 垂直排列 */
            justify-content: space-between;
            align-items: space-between;
            width: 90vw;
            height: 90vh;
            /* 容器宽度为视窗的90% */
        }

        /* 大容器（包含标题和小容器） */
        .big-container {
            display: flex;
            flex-direction: column;
            /* 纵向排列标题和小容器 */
            justify-content: flex-start;
            /*align-items: center;*/
            /* 数据项垂直居中 */
            width: 100%;
            height: 160px;
            margin-bottom: 50px;
            /* 容器间的间距 */
            /* margin-top: 20px; */
            /* 容器与其他容器之间有间距 */
        }

        /* 小容器（包含数据） */
        .small-container {
            display: flex;
            /* 水平布局 */
            width: 100%;
            height: 100%;
            justify-content: center;
            flex-direction: row;
            /* 数据项均匀分布 */
            align-items: center;
            /* 数据项垂直居中 */
            padding: 0px 0px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
            /* 与标题有间距 */
        }

        /* 数据项样式 */
        .data-item {
            flex: 1;
            /* 每个数据项宽度相同 */
            display: flex;
            /* 水平布局 */
            flex-direction: column;
            /* 纵向排列标题和值 */
            text-align: center;
            /* 居中对齐 */
            position: relative;
            /* 为分割线定位 */
        }

        /* 分割线样式 */
        .data-item:not(:last-child)::after {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 1px;
            background-color: #e0e0e0;
            /* 灰色分割线 */
        }

        /* 标题样式 */
        .data-item .title {
            font-weight: 600;
            font-size: 1rem;
            color: #2c3e50;
            /* 深色标题 */
            margin-bottom: 5px;
            /* 标题与值之间的间距 */
        }

        /* 值样式 */
        .data-item .value {
            color: #e74c3c;
            /* 使用亮眼的红色值 */
            font-size: 1.5rem;
            /* 值的字号更大 */
            font-weight: bold;
            /* 强调值 */
        }

        /* 小容器标题样式 */
        .container-small-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            /* 容器标题与数据项之间的间距 */
        }

        /* 第二和第三容器并排样式 */
        .bottom-containers {
            display: flex;
            /* 水平排列两个容器 */
            justify-content: space-between;
            /* 容器间隔 */
            width: 100%;
            /* 占满宽度 */
            flex-grow: 1;
            /* 填充剩余空间 */
            min-height: 150px;
            /* 最小高度为 150px */
            /* margin-top: 20px; */
        }

        /* 每个下方容器 */
        .bottom-container {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: space-between;
            width: 48%;
            /* 每个容器占宽度的48% */
        }

        /* 用例容器（包含数据） */
        .testcase-container {
            display: flex;
            /* 垂直布局 */
            flex-direction: column;
            /* 数据项垂直排列 */
            justify-content: flex-start;
            /* 从顶部开始排列数据项 */
            align-items: stretch;
            /* 数据项占满整个容器宽度 */
            width: 100%;
            height: 100%;
            padding: 0px 0px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
            /* 与标题有间距 */
        }

        /* 用例容器中的数据项 */
        .testcase-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            /* 垂直居中对齐 */
            /* 垂直居中 */
            padding: 10px;
            /* margin-bottom: 5px; */
            /* 与下一个数据项保持距离 */
            font-size: 1rem;
            position: relative;
            /* 为伪元素定位提供参考点 */
            /* background-color: #e74c3c; */
        }

        .testcase-item div {
            margin-right: 30px;
            /* 文件和变量之间的间距 */
        }

        /* 使用::after伪元素创建虚线分隔
        .testcase-item:not(:last-child)::after {
            content: "";
            display: absolute;
            bottom: 0;
            /* 定位到项的底部 
            width: 100%;
            height: 1px;
            background: #e0e0e0;
            margin-top: 15px;
            /* 与下一个数据项保持距离 

        } */

        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
            display: block;
        }

        .node rect {
            fill: #3c6575;
            /* stroke: steelblue;
            stroke-width: 2px; */
        }

        .node text {
            font: 10px sans-serif;
            fill: white;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
    </style>
</head>

<body>

    <!-- 主容器 -->
    <div class="main-container">
        <!-- 第一个大容器 -->
        <div class="big-container">
            <div class="container-small-title">Statistics</div>
            <div class="small-container">
                <div class="data-item">
                    <div class="title">Time(s)</div>
                    <div class="value">-</div>
                </div>
                <div class="data-item">
                    <div class="title">ICov(%)</div>
                    <div class="value">-</div>
                </div>
                <div class="data-item">
                    <div class="title">BCov(%)</div>
                    <div class="value">-</div>
                </div>
                <div class="data-item">
                    <div class="title">TSolver(%)</div>
                    <div class="value">-</div>
                </div>
            </div>
        </div>

        <!-- 第二和第三个大容器并排 -->
        <div class="bottom-containers">
            <!-- 第二个容器 -->
            <div class="bottom-container">
                <div class="container-small-title">Execution Tree</div>
                <div class="small-container">
                    <!-- <pre id="wait">Waiting for output...</pre> -->
                    <svg>
                    </svg>
                </div>
            </div>

            <!-- 第三个容器 -->
            <div class="bottom-container">
                <div class="container-small-title">Testcases</div>
                <div class="testcase-container" id="testcases-container">
                    <!-- 数据项会被插入到这里 -->
                </div>
            </div>
        </div>
    </div>

    <script>

        /******************画布准备******************/

        // 动态设置节点之间的水平和垂直间距，避免重叠
        const treeLayout = d3.tree().nodeSize([120, 80]); // 每个节点的水平和垂直间距

        // 设置 SVG 画布
        // const svg = d3.select("svg")
        //     .attr("viewBox", `0 0 1000 600`) // 设置初始视窗大小
        //     .attr("preserveAspectRatio", "xMidYMid meet"); // 保持比例缩放
        const svg = d3.select("svg");

        // 创建缩放行为
        const zoom = d3.zoom()
            .scaleExtent([0.5, 5])  // 设置缩放范围
            .on("zoom", (event) => {
                g.attr("transform", event.transform);  // 绑定缩放事件
                adjustSvgSize();  // 动态调整 SVG 尺寸
            });

        svg.call(zoom);  // 将缩放行为绑定到 SVG

        const g = svg.append("g").attr("transform", "translate(50,50)");



        let rootNode;
        let firstLoad = true;  // 标志变量：检测是否是首次加载
        // updateTree(data);

        // 监听来自 extension.ts 的消息
        window.addEventListener('message', event => {
            const message = event.data;
            const outputElement = document.getElementById('wait');

            /******************输出执行树******************/

            if (message.type === 'jsonTree') {
                console.log("Received data:", message.content);
                // console.log("Data type:", typeof message.content);
                // if (outputElement.textContent.includes('Waiting for output...')) {
                //     outputElement.textContent = '';
                // }
                let parseData;
                parseData = JSON.parse(message.content);
                // parseData = message.tree;

                parseData.forEach(item => {
                    // 将每个元素的 constraints 转换为合并形式
                    if (item.constraints && Array.isArray(item.constraints)) {
                        const combinedConstraints = item.constraints.join(' && '); // 合并为字符串
                        item.constraints = combinedConstraints; // 替代原来的 constraints
                    }
                });
                console.log(Array.isArray(parseData)); // 输出: true
                console.log(parseData);
                // svg.selectAll("*").remove(); // 清空 SVG 中的所有元素
                // 重新创建 g 元素
                // const g = svg.append("g").attr("transform", "translate(50,50)");
                updateTree(parseData);
            }

            /******************更新用例到树******************/

            else if (message.type === 'ktestOutput') {
                console.log("Received data:", message.content);
                const cases = processKtestOutput(message.content);
                console.log("用例", cases);
                cases.forEach(({ file, variables }) => {
                    addTestCase(rootNode, file, variables);
                });
                console.log(rootNode);
                console.log(Array.isArray(rootNode.data));
                rootNode = d3.hierarchy(rootNode.data);
                // treeLayout(rootNode);


                update(rootNode);
                // updateTree(rootNode.data);

                /******************输出用例******************/

                // 获取容器元素
                const container = document.getElementById('testcases-container');

                // 清空现有内容（如果需要）
                container.innerHTML = '';

                // 遍历数据并动态生成数据项
                cases.forEach(testcase => {
                    const dataItem = document.createElement('div');
                    dataItem.classList.add('testcase-item');

                    // 创建文件名元素
                    const fileElement = document.createElement('div');
                    fileElement.textContent = testcase.file;

                    // 格式化每个变量
                    const variableString = Object.keys(testcase.variables)
                        .map(key => `${key} == ${testcase.variables[key]}`)
                        .join(' && '); // 用 && 连接所有变量

                    // 创建变量显示元素
                    const variableElement = document.createElement('div');
                    variableElement.textContent = variableString;

                    // 将文件名和变量一起添加到容器中
                    dataItem.append(fileElement);
                    dataItem.append(variableElement);
                    // 将整个数据项添加到容器
                    container.append(dataItem);
                });
            }

            /******************输出统计数据******************/

            else if (message.type === 'kstatsOutput') {
                console.log("Received kstatsdata:", message.content);
                const statistics = parseTableData(message.content);
                console.log("statistics", statistics);
                // 获取所有的 .data-item 元素
                const dataItems = document.querySelectorAll(".data-item");
                // console.log(dataItems);

                dataItems.forEach((item) => {
                    // 获取每个统计项的标题（.title）
                    const title = item.querySelector(".title").textContent.trim();
                    // console.log(title);
                    // console.log(typeof (title));
                    // 根据标题从数据对象中找到对应的值
                    if (statistics[title]) {
                        console.log(statistics[title]);
                        // 更新对应的值
                        const valueElement = item.querySelector(".value");
                        valueElement.textContent = statistics[title];
                    }
                });
            }
        });

        function updateTree(data) {
            // // 如果 data 是对象而不是数组，则将其包装为数组
            // const dataArray = Array.isArray(data) ? data : [data];
            // 使用 findRootNode 来查找根节点
            const root = findRootNode(data);
            console.log("根节点", root);

            // 建树
            const tree = buildTree(data);
            console.log("Tree structure:", tree);

            rootNode = d3.hierarchy(tree.get(root.name)); // 初始化 rootNode

            update(rootNode);
            adjustSvgSize();
            // fitToScreen(); // 调整尺寸
        }




        /*******************************************/
        /*******************************************/
        /*************执行树构建所需函数*************/
        /*******************************************/
        /*******************************************/

        // 找根
        function findRootNode(data) {
            const allChildren = data.flatMap(item => item.children || []);  // 确保 children 是数组

            const root = data.find(item => !allChildren.includes(item.name));
            return root;
        }

        // 建树
        function buildTree(data) {
            const nodesMap = new Map(data.map(d => [d.name, { ...d, children: [], _children: [] }]));

            data.forEach(node => {
                node.children.forEach(childName => {
                    const childNode = nodesMap.get(childName);
                    if (childNode) {
                        nodesMap.get(node.name).children.push(childNode);
                    }
                });
            });
            return nodesMap;
        }

        function update(source) {
            // // 重新构建树
            // let newRoot = d3.hierarchy(root.data); // 使用原始数据重新构建树

            // console.log("Root node hierarchy:", newRoot);
            // 确保树布局被正确计算
            treeLayout(rootNode);

            const nodes = rootNode.descendants();
            const links = rootNode.links();
            console.log("Nodes after layout:", nodes);
            console.log("Links after layout:", links);



            // 初始化或更新节点
            // const node = g.selectAll(".node")
            //     .data(nodes, d => d.id || (d.id = ++id));
            const node = g.selectAll(".node")
                .data(nodes, d => d.data.name);

            console.log("D3 node selection:", node);  // 打印选择集
            node.each(d => {
                console.log("Node name:", d.data.name, "Testcase:", d.data.testcase);
            });

            const nodeEnter = node.enter()
                .append("g")
                .attr("class", "node")
                // 初始化节点的 transform，避免 undefined
                .attr("transform", d => `translate(${source.x0 || 0}, ${source.y0 || 0})`)
                .on("click", (event, d) => {
                    console.log("Node clicked:", d.data.name); // 调试输出
                    toggle(d); // 切换展开/折叠状态
                    update(d); // 更新布局
                });
            nodeEnter.each(d => {
                console.log("Node name:", d.data.name, "Testcase:", d.data.testcase);
            });

            nodeEnter.append("rect")
                .attr("width", d => String(d.data.name).length * 6 + 30) // 根据文字长度调整节点宽度
                .attr("height", 30) // 固定节点高度
                .attr("x", d => -(String(d.data.name).length * 3 + 15)) // 让矩形居中
                .attr("y", -15) // 垂直居中
                .attr("rx", 10) // 圆角半径，水平方向
                .attr("ry", 10); // 圆角半径，垂直方向

            nodeEnter.each(d => {
                console.log(d);
                console.log("Node data:", d.data);  // 检查绑定的数据
                console.log(typeof d.data);
                console.log("Node name:", d.data.name);
                console.log("Testcase:", d.data.testcase);
                console.log("Type of testcase:", typeof d.data.testcase);
            });

            nodeEnter.append("text")
                .attr("dy", 4)
                .attr("text-anchor", "middle")
                .text(d => d.data.constraints || d.data.testcase);

            const nodeUpdate = nodeEnter.merge(node);

            // 更新节点位置
            // const transition = firstLoad ? nodeUpdate : nodeUpdate.transition().duration(300);
            const transition = nodeUpdate.transition().duration(300);
            // 更新节点位置
            transition.attr("transform", d => `translate(${d.x || 0}, ${d.y || 0})`);

            node.exit().transition()
                .duration(300)
                .attr("transform", d => `translate(${source.x || 0}, ${source.y || 0})`)
                .remove();

            // 保存节点的当前坐标
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // 更新连线
            const link = g.selectAll(".link")
                .data(links, d => d.target.name);

            const linkEnter = link.enter()
                .insert("path", "g")
                .attr("class", "link")
                .attr("d", d => {
                    const o = { x: source.x0 || 0, y: source.y0 || 0 };
                    return diagonal(o, o);
                });

            link.merge(linkEnter).transition()
                .duration(0)
                .attr("d", d => diagonal(d.source, d.target))
                ;

            link.exit().transition()
                .duration(0)
                .attr("d", d => {
                    const o = { x: source.x || 0, y: source.y || 0 };
                    return diagonal(o, o);
                })
                .remove();

            if (firstLoad) {
                fitToScreen();
            }
            // fitToScreen();
            // 在首次加载完成后，将标志变量设为 false
            firstLoad = false;
        }

        // 画线
        function diagonal(s, d) {
            const sx = s.x || 0, sy = s.y || 0;
            const dx = d.x || 0, dy = d.y || 0;
            // 检查 source 和 target 是否存在
            const sourceX = s.x;
            const sourceY = s.y + 15; // 父节点底部
            const targetX = d.x;
            const targetY = d.y - 15; // 子节点顶部

            // 控制点1：接近父节点底部
            const controlX1 = sourceX;
            const controlY1 = (sourceY + targetY) / 2;

            // 控制点2：接近子节点顶部
            const controlX2 = targetX;
            const controlY2 = (sourceY + targetY) / 2;

            // 使用 d3.path() 构建路径
            const path = d3.path();
            path.moveTo(sourceX, sourceY); // 从父节点底部开始
            path.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, targetX, targetY); // 三次贝塞尔曲线

            return path.toString(); // 返回路径字符串
        }
        // .attr("marker-end", "url(#arrow)")
        ; // 应用箭头
        function toggle(d) {

            if (d.children) {
                d._children = d.children;
                d.children = null;
                // console.log("折叠了", d.data.name)
                // console.log("d.children", d.children)
                // console.log("d._children", d._children)
            } else {
                d.children = d._children;
                d._children = null;
            }
        }

        // 动态调整 SVG 尺寸
        function adjustSvgSize() {
            const bbox = g.node().getBBox();  // 获取内容的边界框
            svg.attr("width", bbox.width + bbox.x * 2)
                .attr("height", bbox.height + bbox.y * 2);
        }

        // 自动缩放和居中图像，留一点 padding 避免紧贴边缘
        function fitToScreen(padding = 20) {
            const bbox = g.node().getBBox(); // 获取内容边界框
            console.log("BBox:", bbox);  // 打印 BBox 检查是否有效

            // 防止 BBox 返回负值的情况
            const width = Math.max(1, bbox.width);  // 最小宽度为 1，防止负值或 0
            const height = Math.max(1, bbox.height);  // 最小高度为 1

            const svgWidth = svg.node().clientWidth;
            const svgHeight = svg.node().clientHeight;

            const widthRatio = (svgWidth - padding * 2) / bbox.width;
            const heightRatio = (svgHeight - padding * 2) / bbox.height;
            const scale = Math.min(widthRatio, heightRatio); // 选择较小的缩放比例

            const x = (svgWidth - bbox.width * scale) / 2 - bbox.x * scale;
            const y = (svgHeight - bbox.height * scale) / 2 - bbox.y * scale;

            // 使用 transition 平滑移动到缩放后的视图
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(x, y).scale(scale)
            );
        }


        /*******************************************/
        /*******************************************/
        /**************添加用例所需函数**************/
        /*******************************************/
        /*******************************************/

        function addTestCase(root, ktestFile, variables) {
            // 生成符合 a==0 && b==1 格式的 testCase 字符串
            const testCase = Object.entries(variables)
                .map(([key, value]) => `${key}==${value}`)
                .join(' && ');
            console.log("这里的类型");
            console.log(typeof testCase);

            console.log(`Generated testCase: ${testCase}`); // 调试输出
            function traverse(node) {

                // 确保 node 和 node.data 存在
                if (!node || !node.data) {
                    console.warn("Node or node.data is undefined:", node);
                    return false;
                }
                // 非叶子节点
                if (node.children && node.children.length > 0) {
                    for (let child of node.children) {
                        if (traverse(child)) {
                            return true;
                        }
                    }
                    return false;
                }
                // 叶子节点
                else {
                    // 用例结点
                    if (!node.data.constraints) {
                        console.error("该结点是用例:", node);
                        return false; // 如果 data 不存在，跳过该节点
                    } else {
                        const constraints = node.data.constraints;
                        console.log(node.data.name);
                        console.log(constraints);
                        console.log(`Checking leaf node with constraints: ${constraints}`);

                        try {
                            const evaluatedConstraints = constraints.replace(
                                new RegExp(Object.keys(variables).join('|'), 'g'),
                                (match) => variables[match]
                            );
                            console.log(`Evaluating constraints: ${evaluatedConstraints}`);

                            const isValid = eval(evaluatedConstraints);
                            console.log(`Result of evaluation: ${isValid}`);

                            if (isValid) {
                                node.children = [];
                                const newChild = JSON.parse(JSON.stringify({
                                    name: ktestFile,
                                    testcase: testCase,
                                    children: [],
                                    x: node.x || 0,
                                    y: node.y || 0,
                                    x0: node.x || 0, // 初始 x0
                                    y0: node.y || 0,  // 初始 y0
                                }));
                                node.children.push(newChild);
                                node.data.children.push(newChild);
                                console.log(`Added test case ${testCase} to node with constraints: ${constraints}`);
                                return true; // 插入成功，结束遍历
                            } else {
                                console.log(`Test case ${testCase} did not meet constraints: ${constraints}`);
                            }
                        } catch (err) {
                            console.error(`Error evaluating constraints: ${err}`);
                        }
                    }
                }
            }
            traverse(root); // 从根节点开始遍历
        }

        function processKtestOutput(output) {
            const lines = output.split('\n');
            const testCases = [];
            let currentKtestFile = null;
            let currentVariables = {}; // 存储当前文件的变量

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // 识别 ktest file 行
                if (line.startsWith('ktest file :')) {
                    if (currentKtestFile && Object.keys(currentVariables).length > 0) {
                        // 保存当前文件的测试用例
                        testCases.push({ file: currentKtestFile, variables: { ...currentVariables } });
                    }
                    currentKtestFile = line.split(':')[1]
                        .trim()
                        .replace(/^'|'$/g, '')  // 去掉首尾单引号
                        .match(/test\d{6}/)[0];  // 提取文件名的核心部分，如 'test000001'
                    currentVariables = {}; // 重置变量集
                    continue;
                }

                // 识别变量和其 int 值
                if (line.startsWith('object') && line.includes('name:')) {
                    const varName = line.split(':')[2].trim().replace(/'/g, '');
                    const intValueLine = lines[i + 4].trim(); // 对应 int 行
                    const intValue = parseInt(intValueLine.split(':')[2].trim(), 10);

                    // 存储变量和值
                    currentVariables[varName] = intValue;
                }
            }

            // 保存最后一个文件的测试用例
            if (currentKtestFile && Object.keys(currentVariables).length > 0) {
                testCases.push({ file: currentKtestFile, variables: { ...currentVariables } });
            }
            return testCases;
        }


        /*******************************************/
        /*******************************************/
        /**************输出数据所需函数**************/
        /*******************************************/
        /*******************************************/

        // 解析函数
        function parseTableData(rawData) {
            // 按行分割数据
            const lines = rawData.trim().split('\n');

            // 提取表头（去掉 | 和多余空格）
            const headers = lines[1]
                .split('|')
                .filter(Boolean)
                .map(header => header.trim());

            // 提取表格数据（第二行数据）
            const rowData = lines[3]
                .split('|')
                .filter(Boolean)
                .map(cell => cell.trim());

            // 将表头和行数据组合成对象
            const parsedData = {};
            headers.forEach((header, index) => {
                parsedData[header] = rowData[index];
            });

            return parsedData;
        }

    </script>
</body>

</html>